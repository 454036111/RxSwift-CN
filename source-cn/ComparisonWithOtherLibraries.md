## RxSwift 与 ReactiveCocoa 的对比

由于 ReactiveCocoa 从 Rx 系列中借鉴了大量的概念，所以在某种程度上 RxSwift 和 ReactiveCocoa 是非常相似的。

本项目其中的一个主要目标是建立一套尽可能简单的 Rx 接口，同时和其他的的 Rx 实现一样，提供了丰富的并发模型，更多的优化能力以及能够紧密的和 Swift 错误处理机制整合。

我们同时也决定不引入任何第三方的依赖，保证本项目仅仅依赖于 Swift/llvm 的编译器。

相对来说，与 ReactiveCoca 最大的不同应该是在与项目在对抽象层的设计上使用了完全不同的思想。

RxSwift 的主要目的是通过可观测序列的形式去提供一个环境无关可组合的计算型抽象胶水层。
然后我们再专注于去提高 RxSwift 在一些具体平台上的体验。为了完成这一目标，RxCocoa 使用计算型泛型抽象来构造更为实用的抽象层并且对 Foundation/Cocoa/UKit 的框架都进行一层封装。这意味着，在 RxSwift 通过提供 `Driver`,`ControlProperty`,`ControlEvent` 等来实现了其他库通过使用计算型泛型的语法来提供相应的接口。

将这些抽象层通过统一的一个概念，也就是 ​_可观测序列（observable sequences）_​，来展现的其中一个好处是所有的计算型抽象接口都会构建在这个概念之上，并且它们都会遵循一套相同的基本原则来组建。它们也都会遵循相同的结构去实现一套相同的接口。
同时，这样的设计也提供了可以非常方便和灵活的去创造订阅（资源）共享策略的方法： `share`, `shareReplay`, `publish`, `multicast`, `shareReplayLatestWhileConnected`...

这个库也提供了容易配置的并发模型。如果使用了并发调度器， 可观测的序列会自动保持序列的属性。对于同一个可观测序列进行的操作会自动探测并优化使用相应的调度器。ReactiveCocoa 则只提供了一个相对来说更多限制的并发模型并且只允许单一连续的调度器。

众所周知，多线程编程是非常困难的，判断其中是否存在闭环更是难上加难。这就是为什么，在 RxSwift 中所有的方法都有着较好的容错机制。即使在产生元素的过程中出现了对自身的递归（死循环），这些方法依然会试图去处理这类异常情况并且防止死锁的产生。这意味着最坏情况下你的程序最多只是抛出了一些错误异常而并不会出现用户不得不去杀死你的应用的情况。更好的一点是，这样子你会相对比较容易去获取你程序的出错信息从而修复问题。
.
